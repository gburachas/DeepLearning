#include <ailab/common.h>
#include <ailab/opencl.h>
#include <ailab/algorithms/rbm.h>
#include <ailab/dataio.h>

#include <stdio.h>
#include <string>
#include <ctime>
#include <iostream>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <signal.h>
#include <ailab/algorithms/rbm.kernels.source.h>

#include <ailab/opencl_cli_mod.h>

/**
 * Defining global flags
 **/
DEFINE_bool(autosave, true,
            "Save weights and biases when complete or interrupted");

DEFINE_bool(train, false, "Run training");

DEFINE_string(name, "", "Override the RBM name");

DEFINE_string(data, "", "Input data path");
DEFINE_string(holdout, "", "Holdout data path");
DEFINE_string(reconstruct, "", "Output file for data reconstruction path");
DEFINE_string(reconSlice, "", 
    "The slice the portion of the file to reconstruct, defaults to all");
DEFINE_string(features, "", "Output features data path");
DEFINE_string(energy, "", "Writes energy to this file is specified");

DEFINE_string(crossData, "", "Input data for the pre-trained RBM");
DEFINE_string(crossRBM, "", 
    "Path to the RBM which we will use to cross build data");

DEFINE_string(
    driver_features,
    "",
    "Path to features generated by a different RBM (unsupervised)"
    ", used to build a 'Supervised' model."
    " Cannot be combined with other training modes.");
DEFINE_string(driver_features_holdout, "",
              "Path to holdout for the driver features");

DEFINE_bool(progress, true, "Log progress to the command line");
DEFINE_int64(logBins, 100,
             "Number of bins to use for histograms (equal width binning)");
DEFINE_int64(logFreq, 0,
             "Number of batches between logging lines (0 means never log)");

DEFINE_int64(reconIters, 1000, "Number of iterations to use when reconstructing");

DEFINE_bool(logHistograms, false, "Include histograms in logs.");
DEFINE_bool(logError, true, "Include error in logs.");
DEFINE_bool(logErrorDetails, false, "Include row and column errors in logs.");
DEFINE_bool(logEnergy, false, "Include energy in logs.");
DEFINE_bool(logEntropy, false, "Include entropy in logs.");
DEFINE_bool(logEffect, false, "Include effect in logs.");

DEFINE_int64(dataBuffer, 50, "Buffer depth");
DEFINE_int64(batch_size, 0, "Non-zero will override the batch size");

DEFINE_string(logFile, "", "Log file");
DEFINE_string(logURL, "", "Log to URL");

// This is global because we need to have it accessible
// in case we get a signal
bool did_training = false;
ailab::spRBM rbm(NULL);
ailab::DataIO<ailab::decimal_t> io;

void save_before_exit(int param) {
  if (rbm != NULL && did_training) {
    rbm->save();
  }
  io.stop();
  exit(0);
}

int main(int argc, char * argv[]) {
#ifndef NDEBUG
  std::cout << "=== Running in Debug Mode ===" << std::endl;
#endif

  ailab::gen.seed( std::chrono::high_resolution_clock::now().time_since_epoch().count() );

  auto starttime = std::chrono::steady_clock::now();

  google::SetUsageMessage("RBM def.json");
  google::ParseCommandLineFlags(&argc, &argv, true);

  if (FLAGS_logFile.size()) {
    ailab::Logger::location.assign(FLAGS_logFile);
    ailab::Logger::factory = &ailab::Logger::initFS;
  } else if (FLAGS_logURL.size()) {
    ailab::Logger::location.assign(FLAGS_logURL);
    ailab::Logger::factory = &ailab::Logger::initHTTP;
  } else {
    ailab::Logger::factory = &ailab::Logger::initSTDOUT;
  }

  if (FLAGS_autosave) {
    signal(SIGINT, save_before_exit);
    signal(SIGTERM, save_before_exit);
    signal(SIGQUIT, save_before_exit);
  }

  ailab::OpenCL::spContext context = ailab::setup_opencl();

  if (context != NULL) {
    context->loadKernels(ailab_rbm_kernels_source, "-cl-denorms-are-zero -cl-single-precision-constant -cl-mad-enable -cl-fast-relaxed-math ");
  }

  rbm = ailab::spRBM(new ailab::RBM(context));

  rbm->output_options = {FLAGS_progress
    , FLAGS_logHistograms
    , FLAGS_logEnergy
    , FLAGS_logError
    , FLAGS_logErrorDetails
    , FLAGS_logEntropy
    , FLAGS_logEffect
    , FLAGS_logFreq
    , FLAGS_logBins};

  ailab::RBM crossrbm(context);
  crossrbm.output_options = rbm->output_options;


  if (argc >= 2) {
    io.start();

    // Initialize from JSON definition
    if (!rbm->init(argv[1], FLAGS_batch_size, FLAGS_name)) {
      std::cerr << "Unable to initialize RBM from " << argv[1] << std::endl;
      exit(-1);
    }

    size_t buffer_size = rbm->params.batchSize * FLAGS_dataBuffer;

    auto data = io.getFiller(FLAGS_data, buffer_size);
    auto holdout = io.getFiller(FLAGS_holdout, buffer_size);

    if (data != NULL) {
      size_t data_width = io.width(FLAGS_data);

      rbm->init_with_visible(data_width);

      if (rbm->verify_ready()) {

        // Do training if needed
        if (FLAGS_train) {

          if (FLAGS_driver_features.length() > 0) {
            auto feature_data = io.getFiller(FLAGS_driver_features,
                                             buffer_size);

            auto feature_holdout = io.getFiller(FLAGS_driver_features_holdout,
                                                buffer_size);

              try {
                if (feature_data == NULL)
                  exit(-1);
                did_training = true;
                rbm->cross_train(data, feature_data, holdout, feature_holdout);
              } catch (std::exception& e) {
              }

          } else if(FLAGS_crossData.length() > 0 && FLAGS_crossRBM.length() > 0)
          {
            auto crossData = io.getFiller(FLAGS_crossData, buffer_size);

            if (crossData != NULL && crossrbm.init(FLAGS_crossRBM, FLAGS_batch_size))
            {
              rbm->cross_train(crossrbm, data, crossData);
            } else {
              std::cerr << "Could not load " << FLAGS_crossRBM << " with " << FLAGS_crossData << std::endl;
            }

          } else {
            did_training = true;
            rbm->train(data, holdout);
          }

          rbm->save();
        }

        if (FLAGS_reconstruct.length() > 0) {
          auto output = io.getDrainer(FLAGS_reconstruct, buffer_size);

          if (output != NULL) {

            if (FLAGS_crossRBM.length() > 0) {


              if (crossrbm.init(FLAGS_crossRBM, FLAGS_batch_size))
              {
                zbin::SelectBox reconSection;
                reconSection.parse( FLAGS_reconSlice );

                rbm->cross_gen(FLAGS_reconIters, reconSection, crossrbm, data, output);
              } else {
                std::cerr << "Could not load " << FLAGS_crossRBM << std::endl;
              }

            } else {

              zbin::SelectBox reconSection;
              reconSection.parse( FLAGS_reconSlice );

              try {
                rbm->reconstruct(reconSection, FLAGS_reconIters, data, output);
              } catch (std::exception& e) {
              }

            }
          }

        }

        if (FLAGS_features.length() > 0) {
          auto output = io.getDrainer(FLAGS_features, buffer_size);

          if (output != NULL) {
            try {
              rbm->gen_features(data, output);
            } catch (std::exception& e) {}
          }
        }

        if (FLAGS_energy.length() > 0) {
          auto output = io.getDrainer(FLAGS_energy, buffer_size);
          if (output != NULL) {
            try {
              rbm->calc_energy(data, output);
            } catch (std::exception& e) {}
          }
        }
      }

    } else {

      auto input = io.getFiller(FLAGS_driver_features, buffer_size);
      auto output = io.getDrainer(FLAGS_reconstruct, buffer_size);

      if ((input != NULL) && (output != NULL)) {

        size_t weights_nvis = rbm->weights_vxh.rows();
        size_t weights_nhid = rbm->weights_vxh.cols();

        // This means we didn't load the weights
        if (weights_nvis == 0 || weights_nhid == 0) {
          std::cerr
              << "We must have a saved model to generate data from features"
              << std::endl;
        } else {

          bool rbm_setup_correctly = rbm->verify_ready();
          if ((weights_nhid == io.width(FLAGS_driver_features))
              && rbm_setup_correctly) {
            rbm->logSetup(12);
            try {
              rbm->gen_from_features(input, output);
            } catch (std::exception& e) {
            }
          } else {

            std::cerr << "Unable to reconstruct from features" << std::endl;

            if (weights_nhid != io.width(FLAGS_driver_features))
              std::cerr << "\tSizes wrong: " << weights_nhid << " vs "
                        << io.width(FLAGS_driver_features) << std::endl;

            if (!rbm_setup_correctly)
              std::cerr << "\tRBM not setup correctly" << std::endl;
          }
        }
      }
    }

  } else {
    std::cerr << "Error: No .json configuration provided" << std::endl;
  }

  auto delta = std::chrono::steady_clock::now() - starttime;
  double microseconds = (std::chrono::duration_cast<std::chrono::microseconds>(
      delta)).count();

  std::cerr << "\nDone in " << (microseconds / 1000000) << "s" << std::endl;

  return 0;
}
